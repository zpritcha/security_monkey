Options
=======

Security Monkey's behavior can be adjusted with options passed using a configuration file or directly using the command line. Some parameters are only available in the configuration file.

If an option is not passed, Security Monkey will use the default value from the file security\_monkey/default-config.py.

You also have the option of providing environment aware configurations through the use of the SECURITY\_MONKEY\_SETTINGS environmental variable.

Any variables set via this variable will override the default values specified in default-config.py

Config File
-----------

### LOG\_LEVEL

Standard python logging levels (ERROR, WARNING, DEBUG) depending on how much output you would like to see in your logs.

### LOG\_FILE

If set, specifies a file to which Security Monkey will write logs. If unset, Security Monkey will log to stderr.

### LOG\_CFG

Can be used instead of LOG\_LEVEL and LOG\_FILE. Should be set to a PEP-0391 compatible logging configuration. Example:

    LOG_CFG = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'standard': {
                'format': '%(asctime)s %(levelname)s: %(message)s '
                    '[in %(pathname)s:%(lineno)d]'
            }
        },
        'handlers': {
            'file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'DEBUG',
                'formatter': 'standard',
                'filename': '/var/log/security_monkey/securitymonkey.log',
                'maxBytes': 10485760,
                'backupCount': 100,
                'encoding': 'utf8'
            },
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'DEBUG',
                'formatter': 'standard',
                'stream': 'ext://sys.stdout'
            }
        },
        'loggers': {
            'security_monkey': {
                'handlers': ['file', 'console'],
                'level': 'DEBUG'
            },
            'apscheduler': {
                'handlers': ['file', 'console'],
                'level': 'INFO'
            }
        }
    }

### R53

Specify if you want Security Monkey to create a DNS entry for itself and what DNS name you would like

### FQDN

This is used for various redirection magic that to get the Security Monkey UI working nice with the API

### SQLALCHEMY\_POOL\_SIZE & SQLALCHEMY\_MAX\_OVERFLOW

Because of the parallel nature of Security Monkey we have to have the ability to tweak the number of concurrent connections we can make. The default values should be sufficient for \<= 20 accounts. This may need to be increased if you are dealing with a greater number of accounts.

### API\_PORT

Needed for CORS whitelisting -- this should match the port you have told Security Monkey to listen on. If you are using nginx it should match the port that nginx is listening on for the /api endpoint.

### WEB\_PORT

Needed for CORS whitelisting -- this should match the port you have configured nginx to listen on for static content.

### WEB\_PATH

### FQDN

To perform redirection security monkey needs to know the FQDN you intend to use. IF R53 is enabled this FQDN will be automatically added to Route53 when Security Monkey starts, assuming the SecurityMonkeyInstanceProfile has permission to do so.

### SQLACHEMY\_DATABASE\_URI

If you have ever used sqlalchemy before this is the standard connection string used. Security Monkey uses a postgres database and the connection string would look something like:

    SQLALCHEMY_DATABASE_URI = 'postgressql://<user>:<password>@<hostname>:5432/SecurityMonkey'

### SECRET_KEY

This `SECRET_KEY` is essential to ensure the sessions generated by Flask cannot be guessed. You must generate a RANDOM SECRET\_KEY for this value.

An example of how you might generate a random string:

    >>> import random
    >>> secret_key = ''.join(random.choice(string.ascii_uppercase) for x in range(6))
    >>> secret_key = secret_key + ''.join(random.choice("~!@#$%^&*()_+") for x in range(6))
    >>> secret_key = secret_key + ''.join(random.choice(string.ascii_lowercase) for x in range(6))
    >>> secret_key = secret_key + ''.join(random.choice(string.digits) for x in range(6))

### SECURITY\_PASSWORD\_SALT

For many of the same reasons we want want a random SECRET\_KEY we want to ensure our password salt is random. see: [Salt](http://en.wikipedia.org/wiki/Salt_(cryptography))

You can use the same method used to generate the SECRET\_KEY to generate the SECURITY\_PASSWORD\_SALT

### Additional Options

As Security Monkey uses Flask-Security for authentication see .. \_Flask-Security: <https://pythonhosted.org/Flask-Security/configuration.html> for additional configuration options.

Command line
------------

### --host and --port

The host and port on which to listen for incoming request. Usually 127.0.0.1 and 8000 to listen locally or 0.0.0.0 and 80 to listen from the outside.

Default: 127.0.0.1 and 8000

Setting file : HOST and PORT

### --version and --help

Display the help or the version of Security Monkey.

Default: None

Configuration file equivalent: None
